<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tyson-with-a-bat-vs.-30-HS-with-a-scissor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; background:#0b1220; }
    #root { height: 100%; }
    canvas { touch-action: none; }
  </style>
  <!-- React & Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    function Game() {
      const canvasRef = useRef(null);
      const containerRef = useRef(null);
      const [running, setRunning] = useState(false);
      const [gameOver, setGameOver] = useState(false);
      const [won, setWon] = useState(false);
      const [hud, setHud] = useState({ enemies: 0, hp: 3, score: 0, time: 0, flame: 0 });
      const [difficulty, setDifficulty] = useState(2); // 1: Easy (24), 2: Normal (30), 3: Hard (36)

      useEffect(() => {
        const canvas = canvasRef.current;
        const parent = containerRef.current;
        if (!canvas || !parent) return;

        // --- Responsive canvas
        const resize = () => {
          const dpr = window.devicePixelRatio || 1;
          const w = Math.min(parent.clientWidth, 1100);
          const h = Math.min(Math.max(parent.clientHeight, 560), 820);
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          const ctx = canvas.getContext("2d");
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        };
        resize();
        const obs = new ResizeObserver(resize);
        obs.observe(parent);

        // --- Helpers & state
        let state = null;              // game state bag
        let animId = 0;
        let last = performance.now();

        const keys = new Set();
        const mouse = { x: 0, y: 0, down: false };
        const touch = { leftId: null, rightId: null, left: null, right: null };

        class Circle { constructor(x,y,r){ this.x=x; this.y=y; this.r=r; } }
        class Rect   { constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; } }

        const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
        const len = (x,y)=>Math.hypot(x,y);
        const norm = (x,y)=>{ const L=Math.hypot(x,y)||1; return [x/L,y/L]; };
        const withinArc = (px,py,cx,cy,ang,arc,range)=>{
          const dx=px-cx, dy=py-cy, d=Math.hypot(dx,dy);
          if(d>range) return false;
          const a=Math.atan2(dy,dx);
          const diff=Math.atan2(Math.sin(a-ang),Math.cos(a-ang));
          return Math.abs(diff)<=arc*0.5;
        };
        const circleRectCollide = (c,r)=>{
          const nx = clamp(c.x, r.x, r.x+r.w);
          const ny = clamp(c.y, r.y, r.y+r.h);
          const dx = c.x-nx, dy=c.y-ny;
          return dx*dx+dy*dy < c.r*c.r;
        };

        // Spawn a power-up in the world
        const spawnPowerUp = (x,y,type)=>{
          if(!state) return;
          state.powerUps.push({ type, x, y, r: 12, t: 0, taken: false });
        };

        function createLevel(){
          const W = parseInt(canvas.style.width);
          const H = parseInt(canvas.style.height);
          const margin = 24;
          const room = { w: W, h: H, margin };
          const obstacles = [];
          // 2x3 desks
          const deskW=120, deskH=60, gapX=40, gapY=40, rows=2, cols=3;
          const startX=(W-(cols*deskW+(cols-1)*gapX))/2;
          const startY=(H-(rows*deskH+(rows-1)*gapY))/2;
          for(let r=0;r<rows;r++){
            for(let c=0;c<cols;c++){
              obstacles.push(new Rect(startX + c*(deskW+gapX), startY + r*(deskH+gapY), deskW, deskH));
            }
          }
          return { W,H,room,obstacles };
        }

        function createGame(){
          const { W,H,room,obstacles } = createLevel();
          const player = {
            x: W*0.5, y: H*0.85, r: 16,
            speed: 230, aim: 0, hp: 3, iFrames: 0,
            swing: { active:false, t:0, duration:0.24, arc:1.9, range:72, cooldown:0 },
            power: { flameT: 0 } // seconds of Flame Bat remaining
          };

          // Enemy setup
          const enemyCount = [24,30,36][clamp(difficulty-1,0,2)]; // default Normal=30
          const enemySpeed = [85,105,125][clamp(difficulty-1,0,2)];
          const enemies = [];
          const spawnRingR = Math.min(W, H) * 0.42;

          for(let i=0;i<enemyCount;i++){
            const a = (i/enemyCount)*Math.PI*2;
            const x = W*0.5 + Math.cos(a)*spawnRingR;
            const y = H*0.45 + Math.sin(a)*spawnRingR*0.7;
            enemies.push({
              x, y,
              r: 14,
              speed: enemySpeed,
              hp: 1,            // normal HP
              elite: false,     // upgraded below
              disarmed:false,
              knockT:0, knockVx:0, knockVy:0,
              touchCd:0
            });
          }

          // Upgrade 5 random enemies to "Olga" elites
          const buffCount = Math.min(5, enemyCount);
          const picks = new Set();
          while(picks.size < buffCount) picks.add(Math.floor(Math.random()*enemyCount));
          for(const idx of picks){
            const e = enemies[idx];
            e.elite = true;
            e.hp = 2;                 // +1 HP
            e.r = 18;                 // bigger
            e.speed = Math.round(e.speed * 0.85); // slower
          }

          const st = { W,H,room,obstacles,player,enemies,score:0,t:0, powerUps: [] };
          setHud({ enemies: enemies.length, hp: player.hp, score: 0, time: 0, flame: 0 });
          setGameOver(false); setWon(false);
          return st;
        }

        function start(){ state = createGame(); setRunning(true); last = performance.now(); loop(last); }
        function stop(win=false){ cancelAnimationFrame(animId); setRunning(false); setGameOver(!win); setWon(win); }

        function handleInput(dt){
          if(!state) return;
          const p = state.player;
          let vx=0, vy=0;
          if(keys.has("ArrowLeft")||keys.has("a")) vx-=1;
          if(keys.has("ArrowRight")||keys.has("d")) vx+=1;
          if(keys.has("ArrowUp")||keys.has("w")) vy-=1;
          if(keys.has("ArrowDown")||keys.has("s")) vy+=1;

          // touch joystick
          if(touch.left){
            const { start, cur } = touch.left;
            const dx = cur.x - start.x, dy = cur.y - start.y;
            const [nx, ny] = norm(dx, dy);
            const mag = Math.min(1, len(dx,dy)/48);
            vx += nx*mag; vy += ny*mag;
          }

          const spd = p.speed*dt; const mv = norm(vx,vy);
          p.x += mv[0]*spd; p.y += mv[1]*spd;

          // walls
          const margin = state.room.margin + p.r;
          p.x = clamp(p.x, margin, state.W - margin);
          p.y = clamp(p.y, margin, state.H - margin);

          // collide with desks
          const pc = new Circle(p.x,p.y,p.r);
          for(const r of state.obstacles){
            if(circleRectCollide(pc,r)){
              const cx=clamp(pc.x,r.x,r.x+r.w), cy=clamp(pc.y,r.y,r.y+r.h);
              const dx=pc.x-cx, dy=pc.y-cy;
              if(Math.abs(dx) > Math.abs(dy)) p.y += Math.sign(dy)*(pc.r - Math.abs(dy) + 0.1);
              else p.x += Math.sign(dx)*(pc.r - Math.abs(dx) + 0.1);
              pc.x=p.x; pc.y=p.y;
            }
          }

          // aim
          if(touch.right){
            const { center, cur } = touch.right;
            p.aim = Math.atan2(cur.y - center.y, cur.x - center.x);
          } else {
            const rect = canvas.getBoundingClientRect();
            const mx = mouse.x - rect.left, my = mouse.y - rect.top;
            p.aim = Math.atan2(my - p.y, mx - p.x);
          }

          // swing timers
          if(p.swing.cooldown>0) p.swing.cooldown -= dt;
          if(p.swing.active){
            p.swing.t += dt;
            if(p.swing.t >= p.swing.duration){
              p.swing.active=false; p.swing.t=0; p.swing.cooldown=0.18;
            }
          }
        }

        function update(dt){
          if(!state) return;
          state.t += dt;
          const p = state.player;

          // power timers
          if(p.power.flameT > 0) p.power.flameT = Math.max(0, p.power.flameT - dt);

          if(p.iFrames>0) p.iFrames -= dt;

          // enemies
          for(const e of state.enemies){
            if(e.disarmed) continue;
            if(e.knockT>0){ e.x += e.knockVx*dt; e.y += e.knockVy*dt; e.knockT -= dt; }
            else { const [nx,ny]=norm(p.x - e.x, p.y - e.y); e.x += nx*e.speed*dt; e.y += ny*e.speed*dt; }

            // obstacle collisions
            const cc = new Circle(e.x,e.y,e.r);
            for(const r of state.obstacles){
              if(circleRectCollide(cc,r)){
                const cx=clamp(cc.x,r.x,r.x+r.w), cy=clamp(cc.y,r.y,r.y+r.h);
                const dx=cc.x-cx, dy=cc.y-cy;
                if(Math.abs(dx) > Math.abs(dy)) e.y += Math.sign(dy)*(cc.r - Math.abs(dy) + 0.1);
                else e.x += Math.sign(dx)*(cc.r - Math.abs(dx) + 0.1);
                cc.x=e.x; cc.y=e.y;
              }
            }

            // contact damage
            if(e.touchCd>0) e.touchCd -= dt;
            const dx=e.x-p.x, dy=e.y-p.y;
            if(dx*dx + dy*dy < (e.r+p.r)*(e.r+p.r)){
              if(e.touchCd<=0 && p.iFrames<=0){
                p.hp -= 1; p.iFrames = 1.2; e.touchCd = 0.7;
                if(p.hp <= 0){ setHud(h=>({...h, hp:0})); stop(false); return; }
              }
            }
          }

          // swing damage + flame aura
          if(p.swing.active){
            const progress = p.swing.t / p.swing.duration;
            const base = p.aim - p.swing.arc * 0.5;
            const curAngle = base + p.swing.arc * progress;
            const flameActive = p.power.flameT > 0;

            for(const e of state.enemies){
              if(e.disarmed) continue;

              const inDirect = withinArc(e.x,e.y,p.x,p.y,curAngle,0.55,p.swing.range);
              const inFlame  = flameActive && !inDirect &&
                               withinArc(e.x,e.y,p.x,p.y,curAngle,1.2,p.swing.range + 10);

              if(inDirect){
                e.hp = (e.hp ?? 1) - 1;
                if(e.hp <= 0){
                  e.disarmed = true; state.score += 100;
                  // Only elites can drop flames (50% chance)
                  if(e.elite && Math.random() < 0.5) spawnPowerUp(e.x, e.y, "flame");
                } else {
                  const [nx,ny]=norm(e.x-p.x, e.y-p.y);
                  e.knockVx = nx*260; e.knockVy = ny*260; e.knockT = 0.12;
                }
                continue;
              }

              if(inFlame){
                e.hp = (e.hp ?? 1) - 1;
                const [nx,ny]=norm(e.x-p.x, e.y-p.y);
                e.knockVx = nx*200; e.knockVy = ny*200; e.knockT = 0.10;
                if(e.hp <= 0){
                  e.disarmed = true; state.score += 100;
                  if(e.elite && Math.random() < 0.5) spawnPowerUp(e.x, e.y, "flame");
                }
              }
            }
          }

          // power-ups: animate & pickup
          for(const pu of state.powerUps){
            if(pu.taken) continue;
            pu.t += dt;
            const dx = pu.x - p.x, dy = pu.y - p.y;
            if(dx*dx + dy*dy < (pu.r + p.r)*(pu.r + p.r)){
              pu.taken = true;
              if(pu.type === "flame"){
                p.power.flameT = Math.max(p.power.flameT, 10); // 10s flame buff
              }
            }
          }
          state.powerUps = state.powerUps.filter(pu => !pu.taken);

          // filter out defeated enemies, check win
          state.enemies = state.enemies.filter(e=>!e.disarmed);
          if(state.enemies.length === 0){ stop(true); }

          // HUD
          setHud({
            enemies: state.enemies.length,
            hp: p.hp,
            score: state.score,
            time: Math.floor(state.t),
            flame: p.power.flameT
          });
        }

        function draw(){
          if(!state) return;
          const ctx = canvas.getContext("2d");
          const { W,H } = state;
          ctx.clearRect(0,0,W,H);

          // background grid
          ctx.fillStyle = "#0b1220"; ctx.fillRect(0,0,W,H);
          ctx.strokeStyle = "#1f2a44"; ctx.lineWidth = 1;
          for(let x=20;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
          for(let y=20;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

          // walls
          ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 3;
          ctx.strokeRect(state.room.margin, state.room.margin, W-state.room.margin*2, H-state.room.margin*2);

          // desks
          ctx.fillStyle = "#1e293b"; ctx.strokeStyle="#475569"; ctx.lineWidth=2;
          for(const r of state.obstacles){ ctx.fillRect(r.x,r.y,r.w,r.h); ctx.strokeRect(r.x,r.y,r.w,r.h); }

          // power-ups
          for(const pu of state.powerUps){
            const bob = Math.sin(pu.t * 6) * 2;
            if(pu.type === "flame"){
              ctx.beginPath();
              ctx.fillStyle = "#fb923c"; // orange outer
              ctx.arc(pu.x, pu.y + bob, pu.r, 0, Math.PI*2);
              ctx.fill();

              ctx.beginPath();
              ctx.fillStyle = "#facc15"; // yellow core
              ctx.arc(pu.x, pu.y + bob, pu.r*0.5, 0, Math.PI*2);
              ctx.fill();

              ctx.beginPath();
              ctx.fillStyle = "rgba(251,146,60,0.7)";
              ctx.arc(pu.x + Math.cos(pu.t*8)*6, pu.y + bob + Math.sin(pu.t*8)*4, 3, 0, Math.PI*2);
              ctx.fill();
            }
          }

          // enemies
          for(const e of state.enemies){
            if(e.disarmed) continue;
            ctx.beginPath();
            if(e.elite){
              ctx.fillStyle = "#3b82f6";          // blue fill
              ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
              ctx.fill();
              ctx.lineWidth = 2;                  // yellow ring
              ctx.strokeStyle = "#facc15";
              ctx.stroke();
            } else {
              ctx.fillStyle = "#ef4444";          // red
              ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
              ctx.fill();
            }
          }

          // player
          const p = state.player;
          ctx.beginPath();
          ctx.fillStyle = p.iFrames>0 ? "#eab308" : "#22c55e";
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fill();

          // aim tick
          ctx.strokeStyle="#93c5fd"; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+Math.cos(p.aim)*26, p.y+Math.sin(p.aim)*26); ctx.stroke();

          // swing arc
          if(p.swing.active){
            const progress = p.swing.t / p.swing.duration;
            const base = p.aim - p.swing.arc * 0.5;
            const curAngle = base + p.swing.arc * progress;

            // main (yellow) arc
            ctx.strokeStyle = "#facc15"; ctx.lineWidth = 6; ctx.lineCap="round";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.swing.range, curAngle - 0.2, curAngle + 0.2);
            ctx.stroke();

            // flame overlay when active
            if(p.power.flameT > 0){
              ctx.strokeStyle = "rgba(251, 146, 60, 0.85)"; // orange
              ctx.lineWidth = 9;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.swing.range + 6, curAngle - 0.26, curAngle + 0.26);
              ctx.stroke();
            }
          }
        }

        function loop(ts){
          animId = requestAnimationFrame(loop);
          const dt = Math.min(0.033, (ts - last)/1000);
          last = ts;
          handleInput(dt);
          update(dt);
          draw();
        }

        // --- Input handlers
        const trySwing = () => {
          if(!state) return;
          const p=state.player;
          if(p.swing.active || p.swing.cooldown>0) return;
          p.swing.active = true; p.swing.t = 0;
        };

        const onKey = (e)=>{ 
          if(e.type==="keydown"){
            keys.add(e.key);
            if(e.key===" ") trySwing();
          } else keys.delete(e.key);
        };
        const onMouseMove = (e)=>{ mouse.x = e.clientX; mouse.y = e.clientY; };
        const onMouseDown = ()=>{ mouse.down=true; trySwing(); };
        const onMouseUp   = ()=>{ mouse.down=false; };

        function screenPos(touchEvent, identifier){
          const rect = canvas.getBoundingClientRect();
          const t = Array.from(touchEvent.changedTouches).find(t=>t.identifier===identifier) || touchEvent.changedTouches[0];
          return { x: t.clientX - rect.left, y: t.clientY - rect.top };
        }
        const onTouchStart = (e)=>{
          for(const t of e.changedTouches){
            const rect = canvas.getBoundingClientRect();
            const pos = { x: t.clientX-rect.left, y: t.clientY-rect.top };
            if(pos.x < canvas.clientWidth*0.5 && touch.leftId === null){
              touch.leftId = t.identifier; touch.left = { start: pos, cur: pos };
            } else if (touch.rightId === null){
              touch.rightId = t.identifier; const center = pos; touch.right = { center, cur: pos };
              trySwing();
            }
          }
        };
        const onTouchMove = (e)=>{
          if(touch.leftId !== null){ const pos = screenPos(e,touch.leftId); if(touch.left) touch.left.cur = pos; }
          if(touch.rightId !== null){ const pos = screenPos(e,touch.rightId); if(touch.right) touch.right.cur = pos; }
        };
        const onTouchEnd = (e)=>{
          for(const t of e.changedTouches){
            if(t.identifier===touch.leftId){ touch.leftId=null; touch.left=null; }
            if(t.identifier===touch.rightId){ touch.rightId=null; touch.right=null; }
          }
        };

        window.addEventListener("keydown", onKey);
        window.addEventListener("keyup", onKey);
        window.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mousedown", onMouseDown);
        canvas.addEventListener("mouseup", onMouseUp);
        canvas.addEventListener("touchstart", onTouchStart, {passive:true});
        canvas.addEventListener("touchmove", onTouchMove, {passive:true});
        canvas.addEventListener("touchend", onTouchEnd);

        // initial render
        state = createGame();
        draw();

        // expose start/reset to buttons
        canvas.__start = start;
        canvas.__reset = ()=>{ state = createGame(); draw(); setRunning(false); setGameOver(false); setWon(false); };

        return () => {
          obs.disconnect();
          cancelAnimationFrame(animId);
          window.removeEventListener("keydown", onKey);
          window.removeEventListener("keyup", onKey);
          window.removeEventListener("mousemove", onMouseMove);
          canvas.removeEventListener("mousedown", onMouseDown);
          canvas.removeEventListener("mouseup", onMouseUp);
          canvas.removeEventListener("touchstart", onTouchStart);
          canvas.removeEventListener("touchmove", onTouchMove);
          canvas.removeEventListener("touchend", onTouchEnd);
        };
      }, [difficulty]);

      const startGame = () => canvasRef.current?.__start?.();
      const resetGame = () => canvasRef.current?.__reset?.();

      return (
        <div ref={containerRef} className="relative w-full h-[92vh] min-h-[560px] flex items-center justify-center bg-slate-900">
          <canvas ref={canvasRef} className="rounded-xl border border-slate-700" />

          {/* HUD left */}
          <div className="absolute top-3 left-3 f
